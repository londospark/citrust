### 2026-02-22: Port Architecture Decision
**By:** Samus (Lead)
**Status:** Proposed
**Scope:** Full project architecture for citrust

---

#### Decision: Single-Crate Structure for Phases 1–3, Workspace for Phase 4+

**Context:** We need a Rust port of b3DSDecrypt.py that grows through 3 optimization phases, then adds a GUI.

**Decision:**
- Phases 1–3: Single crate with `lib.rs` (public API) + `main.rs` (CLI binary). Modules: `keys.rs`, `crypto.rs`, `ncsd.rs`, `ncch.rs`, `decrypt.rs`.
- Phase 4+: Convert to workspace with `citrust-core`, `citrust-cli`, `citrust-gui` crates.
- Rationale: Single crate reduces friction during the critical "get it working" phase. Workspace conversion is mechanical and can be done when GUI work begins.

**Consequences:**
- Link and Fox work in one crate during Phases 1–3
- GUI agent (future) will trigger the workspace split

---

#### Decision: RustCrypto for AES-CTR (`aes` + `ctr` + `cipher`)

**Context:** Need AES-128-CTR for 3DS ROM decryption. Options: RustCrypto, ring, openssl bindings.

**Decision:** Use RustCrypto (`aes`, `ctr`, `cipher` crates).
- Pure Rust, no C dependencies (important for musl static builds)
- Automatic AES-NI via `target-feature=+aes` — no code changes for SIMD
- Well-maintained, audited, widely used

**Rejected:**
- `ring`: Doesn't expose raw AES-CTR with arbitrary IVs/counters easily
- `openssl`: C dependency, complicates cross-compilation and static linking

---

#### Decision: Native u128 for 128-bit Key Arithmetic

**Context:** 3DS key scrambler operates on 128-bit integers: rotate, XOR, add.

**Decision:** Use Rust's native `u128` type.
- `u128::rotate_left()` maps directly to the Python `rol()` lambda
- `u128::wrapping_add()` handles overflow correctly (matches Python's implicit modular arithmetic after masking)
- No external bignum crate needed

---

#### Decision: Test Strategy — Round-Trip via Python Encrypter

**Context:** Test files are already decrypted. We need encrypted inputs to test our decrypter.

**Decision:**
1. Use `b3DSEncrypt.py` to encrypt copies of the decrypted test ROMs → encrypted fixtures
2. Run Rust decrypter on encrypted copies
3. Binary-diff against original decrypted ROMs — must be identical
4. Test fixtures are gitignored (1.7–1.8 GB each); generated by script

**Note:** May need to port `b3DSEncrypt.py` to Python 3 + pycryptodome since Python 2 + pycrypto is end-of-life. Alternatively, use Docker.

---

#### Decision: Benchmarking with criterion + Shell Timing

**Context:** Need to compare Rust performance against Python at each phase.

**Decision:**
- Rust: `criterion` for micro and macro benchmarks
- Python: `Measure-Command` (PowerShell) / `time` (Linux) for wall-clock comparison
- Benchmark script produces comparison table at each phase
- Results tracked in `benches/results/` as JSON

---

#### Decision: SteamOS Packaging — Static Binary (CLI) + AppImage (GUI)

**Context:** Target is SteamOS (Arch Linux, Steam Deck).

**Decision:**
- CLI: Static musl binary — maximum portability, zero dependencies
- GUI (future): AppImage — portable, no root, desktop integration
- Future: Flatpak for SteamOS Discover store integration
- GUI framework: egui/eframe (pure Rust, gamepad-friendly, GPU-rendered)

---

#### Decision: Progress Callback API for Library

**Context:** Both CLI and GUI need progress reporting during decryption of large ROMs (1.7 GB+).

**Decision:** `decrypt_rom()` accepts `impl FnMut(ProgressEvent)` callback. Events: `PartitionStart`, `SectionProgress`, `SectionDone`, etc. CLI uses `indicatif` progress bars; GUI will use egui progress widgets.

---

#### Decision: Include Encryption Support in Phase 1

**Context:** Python has both encrypt and decrypt scripts. Encryption is the inverse operation.

**Decision:** Implement encryption in Phase 1 alongside decryption.
- Validates crypto correctness (encrypt → decrypt → original = round-trip)
- Needed for test fixture creation (can replace Python encrypter)
- Shares 95% of code with decryption (same parsing, keys, AES-CTR — just reversed)
